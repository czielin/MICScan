using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Scripting;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Scripting;
using ParseSardClassic.Extensions;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ParseSardClassic.Datasets
{
    public class MethodCallsDataset : Dataset
    {
        ScriptOptions scriptOptions = ScriptOptions.Default.WithImports("System", "System.Math");
        ConcurrentDictionary<string, bool?> evaluatedConditions = new ConcurrentDictionary<string, bool?>();
        private string projectFilePath;

        public MethodCallsDataset(string projectFilePath)
        {
            this.projectFilePath = projectFilePath;
        }

        protected override string FileName
        {
            get
            {
                return nameof(MethodCallsDataset);
            }
        }

        private async Task<(Example withSource, Example withoutSource)> AddExample(string className, bool isFlawed, SyntaxTree syntaxTree, string source, Compilation compilation = null)
        {
            StringBuilder features;
            features = new StringBuilder();
            features.AppendLine();
            SyntaxNode root = syntaxTree.GetRoot();

            if (compilation == null)
            {
                compilation = await CreateCompilation(syntaxTree, projectFilePath);
            }

            SemanticModel semanticModel = compilation.GetSemanticModel(syntaxTree);

#if DEBUG
            if (semanticModel.GetDiagnostics().Any(d => d.Severity == DiagnosticSeverity.Error))
            {
                foreach (Diagnostic diagnostic in semanticModel.GetDiagnostics().Where(d => d.Severity == DiagnosticSeverity.Error))
                {
                    Console.WriteLine(diagnostic.GetMessage());
                    Console.WriteLine($"{diagnostic.Location.GetLineSpan().Path} {diagnostic.Location.GetLineSpan().StartLinePosition} {diagnostic.Location.GetLineSpan().EndLinePosition}");
                }
                Console.WriteLine(root);
                Console.WriteLine("Included assemblies: ");
                foreach (var assembly in compilation.References)
                {
                    Console.WriteLine(assembly.Display);
                }
            }
#endif

            foreach (SyntaxNode syntaxNode in root.DescendantNodes())
            {
                if
                (
                    syntaxNode is ExpressionSyntax expressionSyntax
                    &&
                    (
                        syntaxNode.IsKind(SyntaxKind.InvocationExpression)
                        || syntaxNode.IsKind(SyntaxKind.ObjectCreationExpression)
                    )
                    && await IsReachable(syntaxNode)
                )
                {
                    string signature = await BuildMethodSignature(expressionSyntax, semanticModel);
                    features.AppendLine(signature);
                }

                if (syntaxNode is AssignmentExpressionSyntax assignmentExpressionSyntax && await IsReachable(assignmentExpressionSyntax))
                {
                    ISymbol leftSymbol = semanticModel.GetSymbolInfo(assignmentExpressionSyntax.Left).Symbol;
                    if (leftSymbol is IPropertySymbol)
                    {
                        string signature = await BuildMethodSignature(assignmentExpressionSyntax.Left, semanticModel);
                        features.AppendLine(signature);
                    }
                }

                if (syntaxNode.IsKind(SyntaxKind.StringLiteralExpression) && syntaxNode.ToString().Contains("^[0-9]*") && await IsReachable(syntaxNode))
                {
                    features.AppendLine("HasNumbersOnlyRegex");
                    //break;
                }

                if (syntaxNode.IsKind(SyntaxKind.StringLiteralExpression) && syntaxNode.ToString().Contains(@"^[\\.\\.\\/]+") && await IsReachable(syntaxNode))
                {
                    features.AppendLine("HasPathTraversalRegex");
                    //break;
                }
            }

            //    PrintDescendentNodes(root, semanticModel);
            //    Console.WriteLine(withoutComments);
            //    Console.WriteLine(features);
            //    Console.ReadLine();
            //}
            //else
            //{
            //    features = new StringBuilder();
            //}

            //Console.WriteLine("Returning Example.");

            return AddExamples(className, isFlawed, features, source);
        }

        public async Task<(Example withSource, Example withoutSource)> AddExample(Document document)
        {
            SyntaxTree syntaxTree = await document.GetSyntaxTreeAsync();
            string content = (await document.GetTextAsync()).ToString();
            Compilation compilation = await document.Project.GetCompilationAsync();
            return await AddExample("", false, syntaxTree, content, compilation);
        }

        public override async Task<(Example withSource, Example withoutSource)> AddExample(string className, bool isFlawed, List<string> fileContents)
        {
            string withoutComments = RemoveComments(fileContents);
            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(withoutComments);
            return await AddExample(className, isFlawed, syntaxTree, withoutComments);
        }

        protected (Example withSource, Example withoutSource) AddExamples(string className, bool isFlawed, StringBuilder features, string source)
        {
            Example withoutSource = new Example { ClassName = className, IsFlawed = isFlawed, Features = features.ToString() };
            datasetWithoutSource.Add(withoutSource);
            features.Insert(0, source);
            Example withSource = new Example { ClassName = className, IsFlawed = isFlawed, Features = features.ToString() };
            datasetWithSource.Add(withSource);
            return (withSource, withoutSource);
        }

        private async Task<string> BuildMethodSignature(ExpressionSyntax invocationExpressionSyntax, SemanticModel semanticModel)
        {
            string signature = await BuildMethodName(invocationExpressionSyntax, semanticModel);
            return signature;
        }

        protected virtual async Task<string> BuildMethodName(ExpressionSyntax invocationExpressionSyntax, SemanticModel semanticModel)
        {
            string methodName = "";
            try
            {
                ISymbol methodSymbol = semanticModel.GetSymbolInfo(invocationExpressionSyntax).Symbol;
                methodName = methodSymbol.ToDisplayString().Replace(" ", "");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error building method name: {invocationExpressionSyntax.ToString()}");
            }
            return methodName;
        }

        protected async Task<bool?> EvaluateCondition(ExpressionSyntax condition)
        {
            bool? evaluationResult;

            string textCondition = condition.ToString();

            if (evaluatedConditions.ContainsKey(textCondition))
            {
                evaluationResult = evaluatedConditions[textCondition];
            }
            else
            {
                try
                {
                    object result = await CSharpScript.EvaluateAsync(textCondition, scriptOptions);
                    if (result is bool booleanResult)
                    {
                        evaluationResult = booleanResult;
                    }
                    else
                    {
                        evaluationResult = null;
                        Console.Error.WriteLine($"Unexpected return type: {result.GetType()}");
                    }
                }
                catch (CompilationErrorException)
                {
                    evaluationResult = null;
                }
            }


            return evaluationResult;
        }

        protected async Task<bool> IsReachable(SyntaxNode syntaxNode)
        {
            bool isReachable = true;

            foreach (var gotoStatement in syntaxNode.Ancestors().SelectMany(a => a.Parent.EarlierSiblings()).Union(syntaxNode.EarlierSiblings()).OfType<GotoStatementSyntax>())
            {
                var labeledStatement = gotoStatement.Parent.ChildNodes().OfType<LabeledStatementSyntax>().Reverse().FirstOrDefault(l => l.ToString().Contains(gotoStatement.ChildNodes().Single().ToString()));

                if (labeledStatement != null)
                {
                    if (gotoStatement.Parent.NodesBetween(gotoStatement, labeledStatement).Any(n => n.DescendantNodesAndSelf().Contains(syntaxNode)))
                    {
                        isReachable = false;
                    }
                }
            }

            // Removing: Do statements always execute once so should be reachable.
            //if (isReachable)
            //{
            //    foreach (var doStatement in syntaxNode.Ancestors().OfType<DoStatementSyntax>())
            //    {
            //        var evaluationResult = await EvaluateCondition(doStatement.Condition);

            //        if (evaluationResult != null)
            //        {
            //            isReachable = evaluationResult.Value && await IsReachable(doStatement);
            //            break;
            //        }
            //    }
            //}

            if (isReachable)
            {
                foreach (var whileStatement in syntaxNode.Ancestors().OfType<WhileStatementSyntax>())
                {
                    var evaluationResult = await EvaluateCondition(whileStatement.Condition);

                    if (evaluationResult != null)
                    {
                        isReachable = evaluationResult.Value && await IsReachable(whileStatement);
                        break;
                    }
                }
            }

            if (isReachable)
            {
                foreach (var ifNode in syntaxNode.Ancestors().OfType<IfStatementSyntax>())
                {
                    bool isInElse = ifNode.Else != null && ifNode.Else.Contains(syntaxNode);

                    var evaluationResult = await EvaluateCondition(ifNode.Condition);

                    if (evaluationResult != null)
                    {
                        isReachable = (isInElse ^ evaluationResult.Value) && await IsReachable(ifNode);
                        break;
                    }
                }
            }

            return isReachable;
        }

        public override string GetPostExecutionOutput()
        {
            return string.Join(Environment.NewLine, evaluatedConditions.Where(k => k.Value == null).Select(k => k.Key));
        }
    }
}
