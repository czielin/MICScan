using ParseSardClassic.Datasets;
using ParseSardClassic.Extensions;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Threading.Tasks.Dataflow;
using System.Xml.Linq;

namespace ParseSardClassic
{
    class Program
    {
        private static List<Dataset> datasets = new List<Dataset>();
        private static readonly string sardRoot = @"..\..\..\sard_archive\";
        private static readonly string outputDirectory = @"..\..\Output";
        private static readonly string cwePattern = @"cwe-*_*\d+";

        private static Stopwatch stopwatch = new Stopwatch();
        private static SemaphoreSlim countSemaphore = new SemaphoreSlim(1, 1);
        private static ConcurrentDictionary<string, int> cweCounts = new ConcurrentDictionary<string, int>();
        private static ConcurrentDictionary<string, int> flawlessCweCounts = new ConcurrentDictionary<string, int>();
        private static int totalCount = 0;
        private static int cSharpCount = 0;
        private static int flawedCount = 0;
        private static int fixedCount = 0;
        private static int mixedCount = 0;
        private static int noFlawOrFix = 0;
        private static int candidateCount = 0;
        private static int approvedCount = 0;
        private static int deprecatedCount = 0;
        private static int testsProcessed = 0;
        //private static int numbersOnlyRegexFlawed = 0;
        //private static int numbersOnlyRegexUnflawed = 0;

        static async Task Main(string[] args)
        {

            stopwatch.Start();

            // Point at where SARD archive has been downloaded and extracted to.
            // https://samate.nist.gov/SARD/archive/sard_archive.zip
            XDocument document = XDocument.Load(Path.Combine(sardRoot, "full_manifest.xml"));
            var testCasesXml = document.Descendants("testcase");

            //datasets.Add(new RemoveCommentsDataset());
            //datasets.Add(new MethodCallsDataset());
            datasets.Add(new ExternalArgumentsDataset());
            //datasets.Add(new NumbersOnlyRegexDataset());

            List<TestCase> testCases = new List<TestCase>();

            foreach (var testCaseElement in testCasesXml)
            {
                var testCase = ParseTestCase(testCaseElement);
                if (testCase != null)
                {
                    testCases.Add(testCase);
                }
            }
            testCases.Shuffle();

            Console.WriteLine($"Finished parsing xml manifest: {stopwatch.Elapsed}");

            //List<Task> parserTasks = new List<Task>();
            //await AddExample(testCase.ClassName, testCase.IsFlawed.Value, files);

            var block = new ActionBlock<TestCase>
            (
                async t => await AddExample(t),
                new ExecutionDataflowBlockOptions
                {
                    MaxDegreeOfParallelism = 24
                }
            );

            foreach (var testCase in testCases)
            {
                await block.SendAsync(testCase);
                //parserTasks.Add(Task.Run(async () => await ProcessTestCase(testCase)));
                //await ProcessTestCase(testCase);
            }

            //await Task.WhenAll(parserTasks);

            block.Complete();
            await block.Completion;

            Console.WriteLine("Number of test cases in manifest: " + totalCount);
            Console.WriteLine("Number of C# test cases: " + cSharpCount);
            Console.WriteLine("Number of test cases with flaws: " + flawedCount);
            Console.WriteLine("Number of test cases with fixes: " + fixedCount);
            Console.WriteLine("Number of test cases with mixed: " + mixedCount);
            Console.WriteLine("Number of tets cases with no flaw or fix: " + noFlawOrFix);
            Console.WriteLine("Number of approved test cases: " + approvedCount);
            Console.WriteLine("Number of candidate test cases: " + candidateCount);
            Console.WriteLine("Number of deprecated test cases: " + deprecatedCount);
            Console.WriteLine("CWE counts with flaws:");
            foreach (var cweCount in cweCounts)
            {
                Console.WriteLine(cweCount.Key + ": " + cweCount.Value);
            }
            Console.WriteLine("CWE counts for test cases without flaws:");
            foreach (var cweCount in flawlessCweCounts)
            {
                Console.WriteLine(cweCount.Key + ": " + cweCount.Value);
            }

            //Console.WriteLine("Numbers only flawed: " + numbersOnlyRegexFlawed);
            //Console.WriteLine("Numbers only without flaws: " + numbersOnlyRegexUnflawed);

            SerializeDatasets();

            stopwatch.Stop();
            Console.WriteLine($"Execution took: {stopwatch.Elapsed}");

            Console.Read();
        }

        private static TestCase ParseTestCase(XElement testCaseElement)
        {
            TestCase testCase = null;
            if
            (
                //totalCount > 228000 &&
                testCaseElement.Attribute("language").Value == "C#"
                && testCaseElement.Elements("file").Count(f => f.Attribute("path").Value.EndsWith(".cs", StringComparison.InvariantCultureIgnoreCase)) == 1
            )
            {
                testCase = new TestCase();
                //await countSemaphore.WaitAsync();
                switch (testCaseElement.Attribute("status").Value)
                {
                    case "Approved":
                        approvedCount++;
                        break;
                    case "Candidate":
                        candidateCount++;
                        break;
                    case "Deprecated":
                        deprecatedCount++;
                        break;
                }
                //countSemaphore.Release();

                //string className = null;
                //bool? isFlawed = null;

                var files = testCaseElement.Elements("file").Where(f => f.Attribute("path").Value.EndsWith(".cs", StringComparison.InvariantCultureIgnoreCase));
                if (files.Any(file => file.Elements("flaw").Any()))
                {
                    testCase.IsFlawed = true;
                    //await countSemaphore.WaitAsync();
                    flawedCount++;
                    //countSemaphore.Release();
                    foreach (var flaw in files.Descendants("flaw"))
                    {
                        testCase.ClassName = ParseCweId(flaw.Attribute("name").Value);
                        if (testCase.ClassName != null)
                        {
                            break;
                        }
                    }
                    if (files.Any(file => file.Descendants("flaw").Any(flawToCheck => testCase.ClassName != ParseCweId(flawToCheck.Attribute("name").Value))))
                    {
                        Console.WriteLine($"Test case found with more than one CWE type:");
                        Console.WriteLine(testCaseElement);
                        Console.ReadLine();
                    }

                    cweCounts.AddOrUpdate(testCase.ClassName, 1, (key, existingValue) => existingValue + 1);
                }
                else if (files.Any(file => file.Elements("fix").Any()))
                { // There aren't currently any fixed C# examples in the SARD. Will need to be updated if this changes.
                    //await countSemaphore.WaitAsync();
                    fixedCount++;
                    //countSemaphore.Release();
                }
                else if (files.Any(file => file.Elements("mixed").Any()))
                { // There aren't currently any fixed C# examples in the SARD. Will need to be updated if this changes.
                    //await countSemaphore.WaitAsync();
                    mixedCount++;
                    //countSemaphore.Release();
                }
                else
                {
                    //await countSemaphore.WaitAsync();
                    noFlawOrFix++;
                    //countSemaphore.Release();
                    testCase.IsFlawed = false;
                    foreach (XElement file in files)
                    {
                        string cweId = ParseCweId(file.Attribute("path").Value);
                        if (cweId != null)
                        {
                            testCase.ClassName = cweId;
                            break;
                        }
                    }
                    if (files.Any(file => testCase.ClassName != ParseCweId(file.Attribute("path").Value)))
                    {
                        Console.WriteLine($"Test case found with more than one CWE type:");
                        Console.WriteLine(testCaseElement);
                        Console.ReadLine();
                    }
                    if (testCase.ClassName == null)
                    {
                        Console.WriteLine($"No CWE match found for test case:");
                        Console.WriteLine(testCaseElement);
                        Console.ReadLine();
                    }
                    flawlessCweCounts.AddOrUpdate(testCase.ClassName, 1, (key, existingValue) => existingValue + 1);
                }

                testCase.FilePaths = files.Select(f => f.Attribute("path").Value);

                if (testCase.IsFlawed == null)
                {
                    throw new NotImplementedException("The 'fix' and 'mixed' test case support is not yet implemented.");
                }

                //await countSemaphore.WaitAsync();
                cSharpCount++;
                //countSemaphore.Release();
            }

            //await countSemaphore.WaitAsync();
            totalCount++;

            //if (totalCount % 1000 == 0)
            //{
            //    Console.WriteLine($"Test cases processed: {totalCount}");
            //    Console.WriteLine($"C# Test cases processed: {cSharpCount}");
            //    Console.WriteLine($"Time elapsed: {stopwatch.Elapsed}");
            //}
            //countSemaphore.Release();

            return testCase;
        }

        private static string ParseCweId(string fullValue)
        {
            string cweId = null;
            Match match = Regex.Match(fullValue, cwePattern, RegexOptions.IgnoreCase);
            if (match.Success)
            {
                cweId = match.Value;
            }
            cweId = cweId.Replace("-", "").Replace("_", "").ToUpper();
            if (cweId.Length == 5)
            {
                cweId = cweId.Insert(3, "0");
            }
            return cweId;
        }

        private static void SerializeDatasets()
        {
            foreach (Dataset dataset in datasets)
            {
                dataset.SaveToFile(outputDirectory);
                Console.WriteLine($"{Environment.NewLine}{dataset.GetType().Name} complete.");
                Console.WriteLine(Environment.NewLine + dataset.GetPostExecutionOutput());
            }
        }

        [DllImport("Kernel32", EntryPoint = "GetCurrentThreadId", ExactSpelling = true)]
        private static extern Int32 GetCurrentWin32ThreadId();

        private static ProcessThread GetCurrentProcessThread()
        {
            ProcessThread currentThread = null;
            int currentThreadId = GetCurrentWin32ThreadId();
            foreach (ProcessThread processThread in Process.GetCurrentProcess().Threads)
            {
                if (processThread.Id == currentThreadId)
                {
                    currentThread = processThread;
                    break;
                }
            }
            return currentThread;
        }

        private static async Task AddExample(TestCase testCase)
        {
            ProcessThread processThread = GetCurrentProcessThread();
            TimeSpan processorTimeAtStart = processThread.TotalProcessorTime;
            List<string> fileContents = new List<string>();
            foreach (string filePath in testCase.FilePaths)
            {
                string fileName = Path.Combine(sardRoot, "testcases", filePath);
                using (var reader = File.OpenText(fileName))
                {
                    string fileContent = await reader.ReadToEndAsync();
                    fileContents.Add(fileContent);
                }
                //fileContents.Add(File.ReadAllText(fileName));
            }
            //if (fileContents[0].Contains("[0-9]"))
            //{
            //    await countSemaphore.WaitAsync();
            //    if (testCase.IsFlawed)
            //    {
            //        numbersOnlyRegexFlawed++;
            //    }
            //    else
            //    {
            //        numbersOnlyRegexUnflawed++;
            //    }
            //    countSemaphore.Release();
            //}
            ConcurrentBag<Example> examples = new ConcurrentBag<Example>();
            foreach (Dataset dataSet in datasets)
            {
                var addedExamples = await dataSet.AddExample(testCase.ClassName, testCase.IsFlawed, fileContents);
                addedExamples.withSource.FinishedProcessing = DateTime.UtcNow;
                addedExamples.withSource.ProcesserTimeConsumedByThread = processThread.TotalProcessorTime - processorTimeAtStart;
                if (addedExamples.withoutSource != null)
                {
                    addedExamples.withoutSource.FinishedProcessing = DateTime.UtcNow;
                    addedExamples.withoutSource.ProcesserTimeConsumedByThread = processThread.TotalProcessorTime - processorTimeAtStart;
                }
            }
            await countSemaphore.WaitAsync();
            testsProcessed++;
            if (testsProcessed % 500 == 0)
            {
                Console.WriteLine($"Tests Processed: {testsProcessed}");
                Console.WriteLine($"Time Elapsed: {stopwatch.Elapsed}");
            }
            countSemaphore.Release();
        }
    }
}
